
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ModtranData</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2024-02-01"><meta name="DC.source" content="ModtranData.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Example usage of MODTRAN data</a></li><li><a href="#2">Obtaining the files</a></li><li><a href="#3">Preparing files</a></li><li><a href="#4">Extracting data</a></li><li><a href="#5">Filtering</a></li><li><a href="#6">Plotting</a></li></ul></div><h2 id="1">Example usage of MODTRAN data</h2><pre class="codeinput"><span class="comment">% Data from MODTRAN can be utilised within the qrackling, in the following steps we will take a folder containing MODTRAN data at different elevations and construct a matrix that we can later use as an input to _environment.Environment_. This then allows for it to be easily incorporated into satellite pass simulations.</span>
</pre><h2 id="2">Obtaining the files</h2><pre class="codeinput"><span class="comment">% Example data can be found the _'Examples/Data'_ folder inside the install location of this toolbox. We can find this by calling _which_ on one of the toolboxes functions.</span>
loc = which(<span class="string">'utilities.readModtranFile'</span>);
[path, ~, ~] = fileparts(loc);
elems = strsplit(path, filesep);
path_root = string(join(elems(1:end-1), filesep)) + filesep;


<span class="comment">% Here we convert file separators so this can be run on any platform</span>
whichSeparator = @(Path, Sep) Sep{cellfun(@(sep) contains(Path, sep), Sep)};
MakePathNative = @(Path) strjoin(strsplit(Path, whichSeparator(Path, {<span class="string">'/'</span>, <span class="string">'\'</span>})), filesep);
example_path = <span class="string">"Examples/Data/atmospheric transmittance/varying elevation MODTRAN data 2/"</span>;
data_path = path_root + MakePathNative(example_path);

<span class="comment">% Now that we have a path for our data (_data_path_) we can find all of the files it contains. Specificially we want the csv files, the following lambda function lets us quickly grab the data files we are looking for.</span>
paths = dir(data_path);
FilterStrings = @(haystack, needle) haystack(arrayfun(@(h) contains(h, needle), haystack));
csv_files = FilterStrings({paths.name}, <span class="string">".csv"</span>);
disp(csv_files')
</pre><pre class="codeoutput">    {'Transm_100km_obs_zen_0deg_scan.csv' }
    {'Transm_100km_obs_zen_10deg_scan.csv'}
    {'Transm_100km_obs_zen_20deg_scan.csv'}
    {'Transm_100km_obs_zen_30deg_scan.csv'}
    {'Transm_100km_obs_zen_40deg_scan.csv'}
    {'Transm_100km_obs_zen_50deg_scan.csv'}
    {'Transm_100km_obs_zen_60deg_scan.csv'}
    {'Transm_100km_obs_zen_70deg_scan.csv'}
    {'Transm_100km_obs_zen_80deg_scan.csv'}
    {'Transm_100km_obs_zen_90deg_scan.csv'}

</pre><h2 id="3">Preparing files</h2><p>The files in this directory following a naming scheme with the folling structure: { data type, visibility, label, zenith label, zenith angle, _, .extensions }. Since we want to read the data in from these files in order of their zenith angles we will have to split their file names into these elements and then sort the array according to zenith angles.</p><pre class="codeinput">schema = {<span class="string">'data_type'</span>, <span class="string">'visibility'</span>, <span class="string">'visibility_label'</span>, <span class="string">'zenith_label'</span>, <span class="string">'zenith_angle'</span>, <span class="string">'end'</span>};
file_details = cellfun(@(f) cell2struct(split(f, <span class="string">"_"</span>), schema), csv_files);
elevations = sort(str2double(replace({file_details.zenith_angle}, <span class="string">"deg"</span>, <span class="string">""</span>)));
sorted_file_names = string( <span class="keyword">...</span>
    arrayfun( <span class="keyword">...</span>
        @(n) csv_files(contains(csv_files, <span class="string">"_"</span> + num2str(n) + <span class="string">"deg"</span>)), <span class="keyword">...</span>
        elevations, <span class="keyword">...</span>
        UniformOutput=false)');
disp(sorted_file_names)
</pre><pre class="codeoutput">    "Transm_100km_obs_zen_0deg_scan.csv"
    "Transm_100km_obs_zen_10deg_scan.csv"
    "Transm_100km_obs_zen_20deg_scan.csv"
    "Transm_100km_obs_zen_30deg_scan.csv"
    "Transm_100km_obs_zen_40deg_scan.csv"
    "Transm_100km_obs_zen_50deg_scan.csv"
    "Transm_100km_obs_zen_60deg_scan.csv"
    "Transm_100km_obs_zen_70deg_scan.csv"
    "Transm_100km_obs_zen_80deg_scan.csv"
    "Transm_100km_obs_zen_90deg_scan.csv"

</pre><h2 id="4">Extracting data</h2><p>With the files now in order we can read in the wavelength and transmission data from each and construct a matrix for them. The <i>utilities.readModtranFile</i> function pull these columns from a typical MODTRAN file.</p><pre class="codeinput">wavelengths = [];
transmissions = [];
<span class="keyword">for</span> f = sorted_file_names'
    [w, t] = utilities.readModtranFile(char(data_path + f));
    wavelengths = [wavelengths, w(~isnan(w))];
    transmissions = [transmissions, t(~isnan(t))];
<span class="keyword">end</span>


<span class="comment">% The _environment.allSkyTransmission_ function then allows us to convert the transmission data into a matrix with dimensions _[numel(headings), numel(elevations)]_ that we can the plot on polar axes.</span>
[sky_transmission, headings] = environment.allSkyTransmission(transmissions, wavelengths(:, 1), elevations);
</pre><h2 id="5">Filtering</h2><p>Since our files contain data for a range of wavelenths we can construct the following lambda functions to find the correct slice of our transmission matrix for a chosen wavelength.</p><pre class="codeinput">Extrema = @(arr) [min(arr), max(arr)];
InRange = @(value, bounds) all([any(value &gt;= bounds), any(value &lt;= bounds)]);
Iota = @(x) linspace(0, x, x+1);
Take = @(arr, choices) arr(choices);
IndexOfWavelength = @(wvls, choice) Take(Iota(numel(wvls)), wvls == choice) * InRange(wvls, Extrema(wvls));
DataAtWavelength = @(data, wvls, choice) squeeze(data(IndexOfWavelength(wvls, choice), :, :));
</pre><h2 id="6">Plotting</h2><p>Picking an example wavelength of 600nm we can then plot the result.</p><pre class="codeinput">wavelength = 600;
T = DataAtWavelength(sky_transmission, wavelengths(:, 1), wavelength);
figure
plots.polarpcolor( <span class="keyword">...</span>
    headings, elevations, T .* 100, <span class="keyword">...</span>
    <span class="string">"Title"</span>, [<span class="string">'All Sky Atmospheric Transmission @ '</span>, num2str(wavelength), <span class="string">'nm'</span>], <span class="keyword">...</span>
    <span class="string">"ColourBarLabel"</span>, <span class="string">'Efficiency (%)'</span>);
</pre><img vspace="5" hspace="5" src="ModtranData_01.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Example usage of MODTRAN data

% Data from MODTRAN can be utilised within the qrackling, in the following steps we will take a folder containing MODTRAN data at different elevations and construct a matrix that we can later use as an input to _environment.Environment_. This then allows for it to be easily incorporated into satellite pass simulations.

%% Obtaining the files

% Example data can be found the _'Examples/Data'_ folder inside the install location of this toolbox. We can find this by calling _which_ on one of the toolboxes functions.
loc = which('utilities.readModtranFile');
[path, ~, ~] = fileparts(loc);
elems = strsplit(path, filesep);
path_root = string(join(elems(1:end-1), filesep)) + filesep;


% Here we convert file separators so this can be run on any platform
whichSeparator = @(Path, Sep) Sep{cellfun(@(sep) contains(Path, sep), Sep)};
MakePathNative = @(Path) strjoin(strsplit(Path, whichSeparator(Path, {'/', '\'})), filesep);
example_path = "Examples/Data/atmospheric transmittance/varying elevation MODTRAN data 2/";
data_path = path_root + MakePathNative(example_path);

% Now that we have a path for our data (_data_path_) we can find all of the files it contains. Specificially we want the csv files, the following lambda function lets us quickly grab the data files we are looking for.
paths = dir(data_path);
FilterStrings = @(haystack, needle) haystack(arrayfun(@(h) contains(h, needle), haystack));
csv_files = FilterStrings({paths.name}, ".csv");
disp(csv_files')


%% Preparing files
% The files in this directory following a naming scheme with the folling structure: { data type, visibility, label, zenith label, zenith angle, _, .extensions }. Since we want to read the data in from these files in order of their zenith angles we will have to split their file names into these elements and then sort the array according to zenith angles.
schema = {'data_type', 'visibility', 'visibility_label', 'zenith_label', 'zenith_angle', 'end'};
file_details = cellfun(@(f) cell2struct(split(f, "_"), schema), csv_files);
elevations = sort(str2double(replace({file_details.zenith_angle}, "deg", "")));
sorted_file_names = string( ...
    arrayfun( ...
        @(n) csv_files(contains(csv_files, "_" + num2str(n) + "deg")), ...
        elevations, ...
        UniformOutput=false)');
disp(sorted_file_names)


%% Extracting data
% With the files now in order we can read in the wavelength and transmission data from each and construct a matrix for them. The _utilities.readModtranFile_ function pull these columns from a typical MODTRAN file.
wavelengths = [];
transmissions = [];
for f = sorted_file_names'
    [w, t] = utilities.readModtranFile(char(data_path + f));
    wavelengths = [wavelengths, w(~isnan(w))];
    transmissions = [transmissions, t(~isnan(t))];
end


% The _environment.allSkyTransmission_ function then allows us to convert the transmission data into a matrix with dimensions _[numel(headings), numel(elevations)]_ that we can the plot on polar axes.
[sky_transmission, headings] = environment.allSkyTransmission(transmissions, wavelengths(:, 1), elevations);


%% Filtering
% Since our files contain data for a range of wavelenths we can construct the following lambda functions to find the correct slice of our transmission matrix for a chosen wavelength.
Extrema = @(arr) [min(arr), max(arr)];
InRange = @(value, bounds) all([any(value >= bounds), any(value <= bounds)]);
Iota = @(x) linspace(0, x, x+1);
Take = @(arr, choices) arr(choices);
IndexOfWavelength = @(wvls, choice) Take(Iota(numel(wvls)), wvls == choice) * InRange(wvls, Extrema(wvls));
DataAtWavelength = @(data, wvls, choice) squeeze(data(IndexOfWavelength(wvls, choice), :, :));


%% Plotting
% Picking an example wavelength of 600nm we can then plot the result.
wavelength = 600;
T = DataAtWavelength(sky_transmission, wavelengths(:, 1), wavelength);
figure
plots.polarpcolor( ...
    headings, elevations, T .* 100, ...
    "Title", ['All Sky Atmospheric Transmission @ ', num2str(wavelength), 'nm'], ...
    "ColourBarLabel", 'Efficiency (%)');


##### SOURCE END #####
--></body></html>