classdef protocol

    properties(SetAccess = protected)
        QKD_protocol qkd_protocols;
        source_requirements = {};
        detector_requirements = {};
    end

    methods

        function protocol = protocol(protoEnum)
            arguments
                protoEnum qkd_protocols
            end

            [rs, rd] = protoEnum.requirements;
            assert(~isempty(rs) | ~isempty(rd), ...
                ['Protocol: \{', string(protoEnum), '\} is not supported']);

            protocol.QKD_protocol = protoEnum;
            protocol.source_requirements = rs;
            protocol.detector_requirements = rd;
        end


        function [Secret_Key_Rate, QBER, Photon_Rate_In, Photon_Rate_Det] = ...
            EvaluateQKDLink( ...
                protocol, Source, Detector, Link_Loss_dB, Background_Count_Rate)

            BCR_Prob = 1 - exp(-Background_Count_Rate * Detector.Time_Gate_Width);
            repetition_rate = Source.Repetition_Rate;
            qber_jitter = Detector.QBER_Jitter;

            switch protocol.QKD_protocol
                case qkd_protocols.BB84
                    [Current_SKR, Current_QBER, R_In, R_Det] = ...
                        BB84_single_photon_model(...
                            Source.Mean_Photon_Number,...
                            Source.g2,...
                            Source.State_Prep_Error,...
                            repetition_rate
                            Detector.Detection_Efficiency,...
                            BCR_Prob, ...
                            Link_Loss_dB,...
                            Protocol.Efficiency,...
                            qber_jitter, ...
                            Detector.Dead_Time,...
                            Detector.Polarisation_Error, ...
                            Detector);

                case qkd_protocols.DecoyBB84
                    %serialise to deal with singular output of decoyBB84_Model
                    assert( isvector(Link_Loss_dB) ...
                            && isvector(Background_Count_Rate), ...
                        'Link loss and BCR must be at most 1-dimensional arrays');
                    %if ~(isvector(Link_Loss_dB)&&isvector(Background_Count_Rate))
                    %    error(...
                    %   'Link loss and BCR must be at most 1-dimensional arrays (i.e vectors)')
                    %end
                    sz=size(Link_Loss_dB);
                    L=max(sz);
                    Secret_Key_Rate=zeros(sz);
                    QBER=nan(sz);
                    Photon_Rate_In=zeros(sz);
                    Photon_Rate_Det=zeros(sz);
                    %prepare input variables
                    MPN=Source.Mean_Photon_Number;
                    SP=Source.State_Probabilities;
                    SPE=Source.State_Prep_Error;
                    DE=Detector.Detection_Efficiency;
                    Eff=Protocol.Efficiency;
                    QBER_Jit=Detector.QBER_Jitter;
                    DT=Detector.Dead_Time;
                    pol_err = Detector.Polarisation_Error;

                    % serialise task
                    for i=1:L
                    %[Current_SKR,Current_QBER]=decoyBB84_model(MPN, SP, SPE, RR,...
                    %                                           DE, BCR_Prob(i), ...
                    %                                           Link_Loss_dB(i), ...
                    %                                           Eff, QBER_Jit, DT, ...
                    %                                           pol_err);
                    [Current_SKR, Current_QBER, R_In, R_Det] = decoyBB84_model(...
                                Source.Mean_Photon_Number, ...
                                Source.State_Probabilities, ...
                                Source.State_Prep_Error, ...
                                repetition_rate,
                                Detector.Detection_Efficiency,
                                BCR_Prob(i),
                                Link_Loss_dB(i),
                                Eff,
                                qber_jitter,
                                DT,
                                pol_err,
                                Detector);
                    end

                case qkd_protocols.E91
                    [Secret_Key_Rate, QBER, Photon_Rate_In, Photon_Rate_Det] = ...
                        ekart92_model( ...
                            repetition_rate
                            Detector.Detection_Efficiency, ...
                            BCR_Prob, ...
                            Link_Loss_dB, ...
                            Protocol.Efficiency, ...
                            qber_jitter,  ...
                            Detector.Dead_Time,
                            Detector);

                case qkd_protocols.COW
                    [Current_SKR, Current_QBER, R_In, R_Det] = ...
                        COW_model(...
                            COW_Source.Mean_Photon_Number, ...
                            COW_Source.State_Prep_Error, ...
                            repetition_rate
                            BCR_Prob, ...
                            Link_Loss_dB,...
                            qber_jitter,  ...
                            COW_Detector.Dead_Time,...
                            COW_Source.State_Probabilities(2),...
                            COW_Detector.Visibility, ...
                            COW_Detector); 

                case qkd_protocols.DPS
                    [Current_SKR, Current_QBER, R_In, R_Det] = ...
                        DPS_model(...
                            Link_Loss_dB, ...
                            DPS_Source.Mean_Photon_Number, ...
                            repetition_rate
                            BCR_Prob, ...
                            DPS_Source.State_Prep_Error,
                            qber_jitter,  ...
                            DPS_Detector.Visibility);

            end

        end

    end

end
