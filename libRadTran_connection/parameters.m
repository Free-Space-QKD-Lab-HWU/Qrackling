classdef parameters < dynamicprops

    properties
    end

    methods
        function obj = parameters()
            obj = aerosol_angstrom(obj);
        end
    end
end

function obj = aerosol_angstrom(obj)
    options = alloptions();
    n_opts = numel(options);
    for i = 1:n_opts
        opt = options{i};
        fields = fieldnames(opt);
        obj.addprop(fields{1});
        obj.(fields{1}) = opt.(fields{1});
    end
end

function name = fnname2optname()
    % Get the name of the function that calls fnname2optname() and remove the
    % last delimeted section. i.e. aerosol_angstrom_func becomes
    % aerosol_angstrom
    stack = dbstack(1);
    fnname = stack.name;
    splits = strsplit(fnname, '_');
    name = strjoin(splits(1:end-1), '_');
end

function s = variableSlots(slots, tags, varargin)
    p = inputParser;
    addRequired(p, 'slots');
    addRequired(p, 'tags');
    addParameter(p, 'parent', '');
    parse(p, slots, tags, varargin{:});

    s = struct;
    for i = 1:numel(slots)
        v = Variable(tags(i));
        v = v.setParent(p.Results.parent);
        s.(slots{i}) = v;
    end
end

function opt = aerosol_angstrom_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'alpha',         'beta'}, ...
        [TagEnum.IsValue, TagEnum.IsValue], ...
        parent=name ...
    );
    opt.alpha.setName = fnname2optname();
end

function opt = aerosol_default_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOnOff, parent=name);
end

function opt = aerosol_file_func()
    name = fnname2optname();
    opt.(name).Type = Variable( ...
        TagEnum.IsOptionResult, ...
        parent=name, ...
        value=OptionResult({'gg', 'ssa', 'tau', 'moments', 'explicit'}));
    opt.(name).File = Variable(TagEnum.IsFile, parent=name);
end

function opt = aerosol_haze_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        parent=name, ...
        Value=OptionResult({ ...
        'Rural type aerosols', 'Maritime type aerosols',    ...
        'Urban type aerosols', 'Tropospheric type aerosols' }));
end

function opt = aerosol_king_byrne_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsArray, ...
        Parent=name, ...
        Value=ArrayResult(Labels={'alpha_0', 'alpha_1', 'alpha_2'}));
end

function opt = aerosol_profile_modtran_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOnOff, Parent=name);
end

function opt = aerosol_season_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult(...
            {'Spring-summer profile', 'Fall-winter profile'}, ...
            Enumerate=true));
end

function opt = aerosol_set_tau_at_wvl_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'lambda',        'tau'}, ...
        [TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = aerosol_species_file_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({ ...
            'continental_clean',    'continental_average', ...
            'continental_polluted', 'urban',               ...
            'maritime_clean',       'maritime_polluted',   ...
            'maritime_tropical',    'desert',              ...
            'antarctic'}));
end

function opt = aerosol_species_library_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'INSO', 'WASO', 'SOOT', 'SSAM', 'SSCM', ...
             'MINM', 'MIAM', 'MICM', 'MITR', 'SUSO'}, ...
            Labels={ ...
            'insoluble',                 'water_soluble', ...
            'soot',                      'sea_salt_accumulation_mode', ...
            'sea_salt_coarse_mode',      'mineral_nucleation_mode', ...
            'mineral_accumulation_mode', 'mineral_coarse_mode', ...
            'mineral_transported',       'sulfate_droplets'}));
end

function opt = aerosol_visibility_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = aerosol_vulcan_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({...
            'Background aerosols',    'Moderate volcanic aerosols', ...
            'High volcanic aerosols', 'Extreme volcanic aerosols'}, ...
            enumerate=true));
end

function opt = albedo_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = albedo_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = albedo_library_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({...
            'evergreen_needle_forest', 'evergreen_broad_forest', ...
            'deciduous_needle_forest', 'deciduous_broad_forest', ...
            'mixed_forest',            'closed_shrub', ...
            'open_shrubs',             'woody_savanna', ...
            'savanna',                 'grassland', ...
            'wetland',                 'cropland', ...
            'urban',                   'crop_mosaic', ...
            'antarctic_snow',          'desert', ...
            'ocean_water',             'tundra', ...
            'fresh_snow'}));
end

function opt = altitude_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'first',         'second'}, ...
        [TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = atm_z_grid_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = atmosphere_file_func()
    %1, Altitude above sea level in km,
    %2, Pressure in hPa,
    %3, Temperature in K,
    %4, air density in cm −3,
    %5, Ozone density in cm −3,
    %6, Oxygen density in cm −3,
    %7, Water vapour density in cm −3,
    %8, CO2 density in cm −3,
    %9, NO2 density in cm −3,
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({...
            'tropics',            'midlatitude_summer',
            'midlatitude_winter', 'subarctic_summer',
            'subarctic_winter',   'US-standard'}, ...
            Labels={
            'Tropical',           'Midlatitude Summer',
            'Midlatitude Winter', 'Subarctic Summer',
            'Subarctic Winter',   'U.S. Standard'}));
end

function opt = bpdf_tsant_u10_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = bdrf_ambrals_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'iso', 'vol', 'geo'}, HasValue=true));
end

function opt = bdrf_ambrals_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = brdf_ambrals_hotspot_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = brdf_cam_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'pcl', 'sal', 'u10', 'uphi', }, HasValue=true));
end

function opt = brdf_cam_solar_wind_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = brdf_hapke_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'w', 'B0', 'h'}, HasValue=true));
end

function opt = brdf_hapke_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = brdf_rpv_func()
    name = fnname2optname();
    opt.(name) = struct;
    opt.(fnname2optname()) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'k', 'rho0', 'theta', 'sigma', 't1', 't2', 'scale'}, ...
            HasValue=true));
end

function opt = brdf_rpv_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = brdf_rpv_library_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = brdf_rpv_type_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = ck_lowtran_absorption_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'O4', 'N2','CO','SO2','NH3','NO','HNO3'}));
end

function opt = cloud_fraction_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = cloud_overlap_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'rand', 'maxrand', 'max', 'off'}));
end

function opt = cloudcover_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'ic', 'wc'}, HasValue=true));
end

function opt = crs_file_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({...
            'O3',   'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', ...
            'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO',  'N2'}));
end

function opt = crs_model_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'rayleigh', 'o3', 'no2', 'o4'}, ...
        [TagEnum.IsOptionResult, TagEnum.IsOptionResult, ...
        TagEnum.IsOptionResult,  TagEnum.IsOptionResult ], ...
        Parent=name);

    opt.(name).rayleigh.Value = OptionResult({ ...
        'Bodhaine', 'Bodhaine29', 'Nicolet', 'Penndorf'});

    opt.(name).o3.Value = OptionResult({ ...
        'Bass_and_Paur', 'Molina', 'Daumont', 'Bogumil', 'Serdyuchenko'});

    opt.(name).no2.Value = OptionResult({'Burrows', 'Bogumil', 'Vandaele'});

    opt.(name).o4.Value = OptionResult({'Greenblatt', 'Thalman'});
end

function opt = data_files_path_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = day_of_year_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = deltam_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOnOff, Parent=name);
end

function opt = disort_intcor_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'phase', 'moments', 'off'}));
end

function opt = earth_radius_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = filter_function_file_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'file', 'normalise'}, ...
        [TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = flourescence_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = flourescence_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = heating_rate_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({'layer_cd', 'local', 'layer_fd'}));
end

function opt = ic_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = ic_fu_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'reff_def', 'deltascaling'}, ...
        [TagEnum.IsOnOff, TagEnum.IsOnOff], ...
        Parent=name);
end

function opt = ic_habit_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({...
            'solid-column', 'hollow-column', 'rough-aggregate', ...
            'rosette-4',    'rosette-6',     'plate', ...
            'droxtal',      'dendrite',      'spheroid'}));
end

function opt = ic_habit_yang2013_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'type', 'roughness'}, ...
        [TagEnum.IsOptionResult, TagEnum.IsOptionResult], ...
        Parent=name);
    opt.(name).type = OptionResult({...
        'column_8elements', 'droxtal',              'hollow_bullet_rosette', ...
        'hollow_column',    'plate',                'plate_10elements',      ...
        'plate_5elements',  'solid_bullet_rosette', 'solid_column'});
    opt.(name).roughness = OptionResult({'smooth', 'moderate', 'severe'});
end

function opt = ic_properties_func()
    name = fnname2optname();
    opt.(name) = variableSlots({ ...
        'fu',       'echam4', 'key',      'yang',      'baum', ...
        'baum_v36', 'hey',    'yang2013', 'filename'}, ...
        [TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, ...
         TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, ...
         TagEnum.IsValue], ...
        Parent=name);
end

function opt = include_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = interpret_as_level_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = isotropic_source_toa_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = latitude_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsPosition, Parent=name);
end

function opt = longitude_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsPosition, Parent=name);
end

function opt = mc_azimuth_old_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = mc_backward_func()
    % add option to variableSlots to allow for arrays?
    % refer to documentation for libRadtran for how this is defined, what kind
    % of token do we need to add to the parser?
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'a', 'b', 'c'}, ...
        [TagEnum.IsCondition, TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = mc_backward_increment_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'ix_step', 'iy_step'}, [TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = mc_backward_output_func()
    % extend parser to add units for abs, emis and heat
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        parent=name, ...
        value=OptionResult({ ...
            'edir', 'edn',  'eup',   'exp', 'exn', 'eyp', 'eyn', 'act', ...
            'abs',  'emis', 'heat'}, ...
        label={...
            'direct horizontal irradiance', ...
            'diffuse downward irradiance (default)', ...
            'diffuse upward irradiance', ...
            'diffuse irradiance in positive x direction for grid box above specified altitude at the left (lower x) face', ...
            'diffuse irradiance in negative x direction for grid box above specified altitude at the left (lower x) face', ...
            'diffuse irradiance in positive y direction for grid box above specified altitude at the front (lower y) face', ...
            'diffuse irradiance in negative y direction for grid box above specified altitude at the front (lower y) face', ...
            'actinic flux', ...
            'absorption', ...
            'emission', ...
            'heating rates, that is absorption + emission'}));
end

function opt = mc_backward_writeback_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = mc_basename_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFileName, Parent=name);
end

function opt = mc_boxairmass_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = mc_escape_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOnOff, Parent=name);
end

function opt = mc_forward_output_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({'absorption', 'actinic', 'emission', 'heating'}));
end

function opt = mc_maxscatters_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_minphotons_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_minscatters_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_nca_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = mc_photons_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_photons_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = mc_polarisation_func()
    name = fnname2optname();
    opt.(name) = Variable(...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({0, 1, 2, 3, -1, -2, -3, 4}, ...
        labels={...
            '(1,0,0,0) (default)', '(1,1,0,0)', '(1,0,1,0)', '(1,0,0,1)', ...
            '(1,-1,0,0)',          '(1,0,-1,0)', '(1,0,0,-1)', 'Random'}));
end

function opt = mc_rad_alpha_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_randomseed_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_sensordirection_func()
    name = fnname2optname();
    opt.(name) = variableSlots({...
        'xvalue', 'yvalue', 'zvalue'}, ...
        [TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = mc_spectral_is_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_spherical_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = mc_surface_reflectalways_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = mc_vroom_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOnOff, Parent=name);
end

function opt = mixing_ratio_func()
    name = fnname2optname();
    opt.(name) = variableSlots({...
        'O2', 'H2O', 'CO2', 'NO2', 'CH4', 'N2O', 'F11', 'F12', 'F22'}, ...
        [TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, ...
         TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue, ...
         TagEnum.IsValue], ...
        Parent=name);
end

function opt = mol_abs_param_func()
    name = fnname2optname();
    opt.(name) = Variable(...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({...
            'reptran',     'reptran_channel', 'crs',      'kato', ...
            'kato2',       'kato2andwandji',  'kato2_96', 'fu',   ...
            'avhrr_kratz', 'lowtran',         'sbdart'}));
    %opt.(name).reptran = OptionResult({'fine', 'medium', 'coarse'});
    %opt.(name).kato = Variable(TagEnum.IsCondition);
    %opt.(name).kato2 = Variable(TagEnum.IsCondition);
    %opt.(name).kato2andwandji = Variable(TagEnum.IsCondition);
    %opt.(name).kato2_96 = Variable(TagEnum.IsCondition);
    %opt.(name).fu = Variable(TagEnum.IsCondition);
    %opt.(name).avhrr_kratz = Variable(TagEnum.IsCondition);
    %opt.(name).lowtran = Variable(TagEnum.IsCondition);
    %opt.(name).sbdart = Variable(TagEnum.IsCondition);
end

function opt = mol_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = mol_modify_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'species', 'column', 'unit'}, ...
        [TagEnum.IsOptionResult, TagEnum.IsValue, TagEnum.IsOptionResult], ...
        Parent=name);
    opt.(name).species.Value = OptionResult({...
        'O3',  'O2',  'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', ...
        'SO2', 'CH4', 'N2O', 'CO',  'N2'});
    opt.(name).unit.Value = OptionResult({'DU', 'CM_2', 'MM'}, ...
        labels={'Dobson units', 'molecules/cm^2', 'kg/m^2'});
end

function opt = mol_tau_file_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'ScatteringOrAbsorption', 'filename'}, ...
        [TagEnum.IsOptionResult, TagEnum.IsFile], ...
        Parent=name);
    opt.(name).ScatteringOrAbsorption.Value = OptionResult({'sca', 'abs'});
end

function opt = n02_column_du_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsObsolete, Parent=name);
end

function opt = n02_column_moleccm_2_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsObsolete, Parent=name);
end

function opt = no_absorption_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'mol', 'aer', 'wc', 'ic', 'profile'}, ...
            Labels={ ...
            'Switch off molecular scattering', ...
            'Switch off scattering by aerosols', ...
            'Switch off scattering by water clouds', ...
            'Switch off scattering by ice clouds'}));
end

function opt = no_scattering_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'mol', 'aer', 'wc', 'ic', 'profile'}, ...
            Labels={ ...
            'Switch off molecular scattering', ...
            'Switch off scattering by aerosols', ...
            'Switch off scattering by water clouds', ...
            'Switch off scattering by ice clouds'}));
end

function opt = number_of_streams_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = output_format_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = output_process_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'sum', 'integrate', 'per_nm', 'per_cm-1', 'per_band', 'none'}, ...
            labels = { ...
            'Sum output over wavelength. Useful in combination with the mol_abs_param option (kato, kato2, kato2.96, Fu, avhrr_kratz). In case of mol_abs_param reptran, the units are automatically converted to per_band before summation.', ...
            'Integrate output over wavelength for solar and over wavenumber for thermal simulations. Useful for spectral calculations, mol_abs_param lowtran and reptran.', ...
            'Output is given in W/(m 2 nm) or mW/(m 2 nm) (W or mW is determined by the extraterrestrial spectrum.)', ...
            'Output is given in W/(m 2 cm −1 ) or mW/(m 2 cm −1 ).', ...
            'Output is given in W/m 2 or mW/m 2 per correlated-k or reptran band. (This option can not be used for spectral calculations and mol_abs_param LOWTRAN in the solar range.)', ...
            'No processing - output spectral information (default)'}));
end

function opt = output_quantity_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult( ...
            {'brightness', 'reflectivity', 'transmittance'}, ...
            labels={ ...
            'Convert radiances / irradiances to equivalent brightness temperatures.', ...
            'Calculate transmission / reflectivity instead of absolute quantities. For irradiances / actinic fluxes the transmission T is defined as, T = E / (E_0 cosθ), where E is the irradiance / actinic flux, E_0 is the extraterrestrial flux, and θ is the solar zenith angle. The reflectivity R is defined as, R = (π · L) / (E_0 cosθ), where L is the radiance, E 0 is the extraterrestrial flux, and θ is the solar zenith angle. Obviously, reflectivities do not depend on Sun-Earth distance. Please note the difference to transmittance.', ...
            'Calculate transmittance / reflectance instead of absolute quantities. That is, set the extraterrestrial irradiance to 1 and do not correct for Sun-Earth distance, T = E / E_0, where E is the irradiance / actinic flux / radiance and E 0 is the extraterrestrial flux. Please note the difference to reflectivity.', ...
        }));
end

function opt = output_user_func()
    name = fnname2optname();
    opt.(name) = Variable( ...
        TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({ ...
    'lambda',   'wavenumber', 'sza',     'zout',      'edir',     'eglo',     ...
    'edn',      'eup',        'enet',    'esum',      'uu',       'fdir',     ...
    'fglo',     'fdn',        'fup',     'f',         'uavgdir',  'uavgglo',  ...
    'uavgdn',   'uavgup',     'uavg',    'spher_alb', 'albedo',   'heat',     ...
    'p',        'T',          'T_d',     'T_sur',     'theta',    'theta_e',  ...
    'n_AIR',    'rho_AIR',    'mmr_AIR', 'vmr_AIR',   'n_O3',     'rho_O3',   ...
    'mmr_O3',   'vmr_O3',     'n_O2',    'rho_O2',    'mmr_O2',   'vmr_O2',   ...
    'n_H20',    'rho_H20',    'mmr_H20', 'vmr_H20',   'n_CO2',    'rho_CO2',  ...
    'mmr_CO2',  'vmr_CO2',    'n_NO2',   'rho_NO2',   'mmr_NO2',  'vmr_NO2',  ...
    'n_BRO',    'rho_BRO',    'mmr_BRO', 'vmr_BRO',   'n_OCLO',   'rho_OCLO', ...
    'mmr_OCLO', 'vmr_OCLO',   'n_HCHO',  'rho_HCHO',  'mmr_HCHO', 'vmr_HCHO', ...
    'n_O4',     'rho_O4',     'mmr_O4',  'vmr_O4',}, ...
        Labels={...
        'Wavelength in nm.', 'Wave number in cm −1 .', 'solar zenith angle', ...
        'Output altitude in km.', 'Direct irradiance', 'Global irradiance', ...
        'Diffuse downward irradiance', 'Diffuse upward irradiance', ...
        'Radiance uu(umu(0),phi(0))', 'Radiance uu(umu(0),phi(m))', ...
        'Radiance uu(umu(n),phi(0))', 'Radiance uu(umu(n),phi(m))', ...
        'Direct actinic flux', 'Global actinic flux', ...
        'Diffuse downward actinic flux', 'Diffuse upward actinic flux', ...
        'Total actinic flux', 'Direct mean intensity', ...
        'Global mean intensity', 'Diffuse downward mean intensity', ...
        'Diffuse upward mean intensity', ...
        'Total diffuse mean intensity (= actinic flux / 4π)', ...
        'Spherical albedo of the complete atmosphere.', ...
        'Albedo.', 'Heating rate in K/day.', 'pressure [hPa], ,', ...
        'temperature [K],', 'dewpoint temperature [K]', ...
        'surface temperature [K]', 'potential temperature [K]', ...
        'equivalent potential temperature [K]', ...
        'number density of the gas AIR [cm −3 ]', ...
        'mass density of the gas AIR [kg/m 3 ]', ...
        'mass mixing ratio of the gas AIR [kg/kg]', ...
        'volume mixing ratio of the gas AIR [m 3 /m 3 ]', ...
        'number density of the gas O3 [cm −3 ]', ...
        'mass density of the gas O3 [kg/m 3 ]', ...
        'mass mixing ratio of the gas O3 [kg/kg]', ...
        'volume mixing ratio of the gas O3 [m 3 /m 3 ]', ...
        'number density of the gas O2 [cm −3 ]', ...
        'mass density of the gas O2 [kg/m 3 ]', ...
        'mass mixing ratio of the gas O2 [kg/kg]', ...
        'volume mixing ratio of the gas O2 [m 3 /m 3 ]', ...
        'number density of the gas H20 [cm −3 ]', ...
        'mass density of the gas H20 [kg/m 3 ]', ...
        'mass mixing ratio of the gas H20 [kg/kg]', ...
        'volume mixing ratio of the gas H20 [m 3 /m 3 ]', ...
        'number density of the gas CO2 [cm −3 ]', ...
        'mass density of the gas CO2 [kg/m 3 ]', ...
        'mass mixing ratio of the gas CO2 [kg/kg]', ...
        'volume mixing ratio of the gas CO2 [m 3 /m 3 ]', ...
        'number density of the gas NO2 [cm −3 ]', ...
        'mass density of the gas NO2 [kg/m 3 ]', ...
        'mass mixing ratio of the gas NO2 [kg/kg]', ...
        'volume mixing ratio of the gas NO2 [m 3 /m 3 ]', ...
        'number density of the gas BRO [cm −3 ]', ...
        'mass density of the gas BRO [kg/m 3 ]', ...
        'mass mixing ratio of the gas BRO [kg/kg]', ...
        'volume mixing ratio of the gas BRO [m 3 /m 3 ]', ...
        'number density of the gas OCLO [cm −3 ]', ...
        'mass density of the gas OCLO [kg/m 3 ]', ...
        'mass mixing ratio of the gas OCLO [kg/kg]', ...
        'volume mixing ratio of the gas OCLO [m 3 /m 3 ]', ...
        'number density of the gas HCHO [cm −3 ]', ...
        'mass density of the gas HCHO [kg/m 3 ]', ...
        'mass mixing ratio of the gas HCHO [kg/kg]', ...
        'volume mixing ratio of the gas HCHO [m 3 /m 3 ]', ...
        'number density of the gas O4 [cm −3 ]', ...
        'mass density of the gas O4 [kg/m 3 ]', ...
        'mass mixing ratio of the gas O4 [kg/kg]', ...
        'volume mixing ratio of the gas O4 [m 3 /m 3 ]', ...
        'rh', 'rh_ice', 'c_p', 'CLWC', 'CLWD', 'CIWC', 'CIWD', 'TCC', ...
        'relative humidity over water [percent]', ...
        'relative humidity over ice [percent]', ...
        'specific heat capacity of the air (humidity and temperature dependent)', ...
        'cloud liquid water content [kg/kg]', ...
        'cloud liquid water density [g/m 3 ]', ...
        'cloud ice water content [kg/kg]', ...
        'cloud ice water density [g/m 3 ]', ...
        'total cloud cover [0-1]'}));
end

function opt = ozone_column_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsObsolete, Parent=name);
end

function opt = phi_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = phi0_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = polradtran_func()
    name = fnname2optname();
    opt.(name) = variableSlots( ...
        {'aziorder', 'nstokes', 'src_code'}, ...
        [TagEnum.IsValue, TagEnum.IsOptionResult, TagEnum.IsOptionResult], ...
        Parent=name);
    opt.(name).nstokes.Value = OptionResult( ...
        {'I', 'IQU', 'IQUV'}, ...
        Enumerate=true);
    opt.(name).src_code.Value = OptionResult( ...
        {'0', '1', '2', '3'}, Labels={'None', 'Solar', 'Thermal', 'Both'}, ...
        Enumerate=true);
end

function opt = polradtran_max_delta_tau_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = polradtran_quad_type_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, Parent=name, ...
        Value=OptionResult({'G', 'D', 'L', 'E'}, ...
            Labels={...
                'Gaussian', 'Double Gaussian', 'Lobatto', 'extra-angle(s)'} ...
        ));
end

function opt = pressure_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = pressure_out_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = print_disort_info_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = profile_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = profile_modify_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = psuedospherical_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = quiet_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = radiosonde_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = radiosonde_levels_only_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = raman_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, Parent=name, ...
        Value=OptionResult({'original'}));
end

function opt = rayleigh_depol_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = refractive_index_pv_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = reptran_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = reverse_atmosphere_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = rte_solver_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, ...
        Parent=name, ...
        Value=OptionResult({ ...
        'disort',               'twostr',    'fdisort1',    'fdisort2',   ...
        'sdisort',              'spsdisort', 'polradtran',  'ftwostr',    ...
        'rodents',              'twomaxrnd', 'twomaxrnd3C', ...
        'twomaxrnd3C_scale_cf', 'sslidar',   'sos',         'montecarlo', ...
        'mystic',               'tzs',       'sss'}));

% C-version of the disort algorithm, translated from Fortran by Tim Dowling. This is the recommended discrete ordinate code in libRadtran. For documentation see src_f/DISORT2.doc as well as the papers and the DISORT report at ftp://climate1.gsfc.nasa.gov/wiscombe/Multiple_Scatt/. The intensity correction can be performed according to Nakajima and Tanaka (1988) using disort_intcor moments (like in the original code), or with the improvements described in (Buras, Dowling, Emde, in preparation; default). Can be run in plane-parallel geometry (default) or in pseudo-spherical geometry (using pseudospherical).
% 
% C-version of the two–stream radiative transfer solver described by Kylling et al. (1995). Can be run in plane-parallel geometry (default) or in pseudo-spherical geometry (using pseudospherical ).
% 
% The standard plane–parallel disort algorithm by Stamnes et al. (1988), version 1.3 – provided for compatibility reasons. Use only if you have troubles with the default disort or for historical reasons. For documentation see src_f/DISORT.doc as well as the papers and the DISORT report at ftp://climate1.gsfc.nasa.gov/wiscombe/Multiple_Scatt/. To optimize for computational time and memory, please adjust the parameters in src_f/DISORT.MXD for your application and re-compile. For your application please use rte_solver fdisort2 which is the advanced version, unless you e.g. want to explore how a specific feature of fdisort2 (e.g. the Nakajima and Tanaka (1988) intensity correction) improves the fdisort1 result.
% 
% Version 2 of the Fortran algorithm disort – provided for compatibility reasons. Use only if you have troubles with the default disort or for historical reasons. For documentation see src_f/DISORT2.doc as well as the papers and the DISORT report at ftp://climate1.gsfc.nasa.gov/wiscombe/Multiple_Scatt/fdisort2 has several improvements compared to its ’ancestor’ fdisort1 (version 1.3). To optimize for computational time and memory, please adjust the parameters in src_f/DISORT.MXD for your application and re-compile. Note! fdisort2 is a new version of the original disort code which was implemented in summer 2009. It uses phase functions to calculate the intensity corrections by Nakajima and Tanaka (1988) instead of Legendre moments. Hence it needs cloud properties files which contain the phase functions. It is still possible to use the old version of disort, you need to specify disort_intcor moments.
% 
% Pseudospherical disort as described by Dahlback and Stamnes (1991). Double precision version. To optimize for computational time and memory, please adjust the parameters in src_f/DISORT.MXD for your application and recompile.
% 
% Pseudospherical disort as described by Dahlback and Stamnes (1991), single precision version. Warning: it is not recommended to use spsdisort for really large solar zenith angles nor for cloudy conditions. For large optical thickness it is numerically unstable and may produce wrong results. To optimize for computational time and memory, please adjust the parameters in src_f/DISORT.MXD for your application and re-compile.
% 
% The plane-parallel radiative transfer solver of Evans and Stephens (1991). Includes polarization. The full implementation of the polRadtran solver in uvspec is quite new (version 1.4). If you find unusual behaviour, please contact the libRadtran authors.
% 
% Original Fortran-version of the two–stream radiative transfer solver described by Kylling et al. (1995), in pseudo-spherical geometry.
% 
% Delta-Eddington two–stream code (RObert’s Delta-EddingtoN Two-Stream), plane-parallel.
% 
% Delta-Eddington two–stream solver with Maximum-Random-Overlap according to Zdunkowski et al. (2007) by Nina Crnivec. As inputs, a wc_file 1D and/or a ic_file 1D are required, plus a cloud_fraction_file. The same cloud fraction is used for water and ice clouds. zout_interpolate is activated automatically. See Črnivec and Mayer (2019) for more details.
% 
% Delta-Eddington two–stream solver with Maximum-Random-Overlap according to Zdunkowski et al. by Nina Crnivec. In addition to twomaxrnd "tripleclouds" by Shonk and Hogan (2008) is considered. A cloud_fraction_file has to be specified as well as two cloudy columns, defined as profiles wcn (optically thiN) and wck (optically thicK clouds), e.g. profile_file wcn 1D ./wcn.dat. zout_interpolate is activated automatically.See Črnivec and Mayer (2020), in particular appendix A.
% 
% Scaling factor for cloud fraction split.
% 
% A simple single scattering lidar simulator by Robert Buras.
% 
% A scalar pseudospherical succesive orders of scattering code. Works for solar zenith angles smaller than 90 degrees. Can calculate azimuthally averaged radiances. Set sos_nscat to specify the order of scattering.
% 
% The MYSTIC Monte Carlo code. Monte Carlo is the method of choice (1) for horizontally inhomogeneous problems; (2) whenever polarization is involved; (3) for applications where spherical geometry plays a role; and (4) whenever sharp features of the scattering phase function play a role, like for the calculation of the backscatter glory or the aureole.
% 
% Same as montecarlo.
% 
% TZS stands for "thermal, zero scattering" and is a very fast analytical solution for the special case of thermal emission in a non-scattering atmosphere. Please note that TZS does only radiance calculations at top of the atmosphere. "Black-body clouds" may be included using the option tzs_cloud_top_height.
% 
% SSS stands for "solar, single scattering" and is an analytical single scattering approximation which might be reasonable for an optically thin atmosphere. Please note that SSS does only radiance calculations at top of the atmosphere. This is an experimental solver - be careful!
% 
% null
end

function opt = sdisort_func()
    name = fnname2optname();
    opt.(name) = variableSlots({'nscat', 'nrefrac'}, ...
        [TagEnum.IsOptionResult, TagEnum.IsOptionResult], ...
        Parent=name);
    opt.(name).nscat.Value = OptionResult({'single', 'full'}, Enumerate=true);
    opt.(name).nrefrac.Value = OptionResult({'None', 'Harsh', 'Accurate'}, ...
        Enumerate=true, Labels={'Default', ...
                                'Refraction included using fast method', ...
                                'Refraction included using slow method'});
end

function opt = slit_function_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = source_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, Parent=name, ...
        Value=OptionResult({'solar', 'thermal'}));
end

function opt = spline_func()
    name = fnname2optname();
    opt.(name) = variableSlots(...
        {'lambda_0', 'lambda_1', 'lambda_2'}, ...
        [TagEnum.IsValue, TagEnum.IsValue, TagEnum.IsValue], ...
        Parent=name);
end

function opt = spline_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = sslidar_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, Parent=name, ...
        Value=OptionResult({'area', 'E0', 'eff', 'position', 'range'}));
end

function opt = sslidar_nranges_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = sslidar_polarisation_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = sur_temperature_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = surface_type_map_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = sza_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = sza_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = thermal_binds_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = thermal_bandwidth_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = time_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = twomaxrnd3C_scale_cf_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = tzs_cloud_top_height_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsValue, Parent=name);
end

function opt = umu_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsArray, Parent=name);
end

function opt = verbose_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = wavelength_func()
    name = fnname2optname();
    opt.(name) = variableSlots({'lambda_0', 'lambda_1'}, ...
        [TagEnum.IsValue, TagEnum.IsValue], Parent=name);
end

function opt = wavelength_grid_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsFile, Parent=name);
end

function opt = wavelength_index_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsArray, Parent=name);
end

function opt = wc_file_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsOptionResult, ...
        Parent=name, ...
        value=OptionResult({'1D', 'ipa_files', 'moments'}));
end

function opt = wc_modify_func()
    name = fnname2optname();
    opt.(name) = variableSlots({'gg', 'ssa', 'tau', 'tau550'}, ...
        [TagEnum.IsSetScale, TagEnum.IsSetScale, ...
         TagEnum.IsSetScale, TagEnum.IsSetScale], ...
        Parent=name);
end

function opt = wc_properties_func()
    name = fnname2optname();
    opt.(name) = variableSlots(...
        {'hu', 'echam4', 'mie', 'filename'}, ...
        [TagEnum.IsCondition, TagEnum.IsCondition, ...
         TagEnum.IsCondition, TagEnum.IsCondition], ...
        Parent=name);
end

function opt = z_interpolate_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = zout_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsArray, Parent=name);
end

function opt = zout_interpolate_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsCondition, Parent=name);
end

function opt = zout_sea_func()
    name = fnname2optname();
    opt.(name) = Variable(TagEnum.IsArray, Parent=name);
end

function options = alloptions()
    range = @(Start, Stop) linspace(Start, Stop, Stop);
    options = {...
        aerosol_angstrom_func(), ...
        aerosol_default_func(), ...
        aerosol_file_func(), ... % broken...
        aerosol_haze_func(), ...
        aerosol_king_byrne_func(), ...
        aerosol_profile_modtran_func(), ...
        aerosol_season_func(), ...
        aerosol_set_tau_at_wvl_func(), ...
        aerosol_species_file_func(), ...% this should be list [n]aero
        aerosol_species_library_func(), ...
        aerosol_visibility_func(), ...
        aerosol_vulcan_func(), ...
        albedo_func(), ...
        albedo_file_func(), ...
        albedo_library_func(), ...
        altitude_func(), ...
        atm_z_grid_func(), ...
        atmosphere_file_func(), ...
        bpdf_tsant_u10_func(), ...
        bdrf_ambrals_func(), ...
        bdrf_ambrals_file_func(), ...
        brdf_ambrals_hotspot_func(), ...
        brdf_cam_func(), ...
        brdf_cam_solar_wind_func(), ...
        brdf_hapke_func(), ...
        brdf_hapke_file_func(), ...
        brdf_rpv_func(), ...
        brdf_rpv_file_func(), ...
        brdf_rpv_library_func(), ...
        brdf_rpv_type_func(), ...
        ck_lowtran_absorption_func(), ...
        cloud_fraction_file_func(), ...
        cloud_overlap_func(), ...
        cloudcover_func(), ...
        crs_file_func(), ...
        crs_model_func(), ...
        data_files_path_func(), ...
        day_of_year_func(), ...
        deltam_func(), ...
        disort_intcor_func(), ...
        earth_radius_func(), ...
        filter_function_file_func(), ...
        flourescence_func(), ...
        flourescence_file_func(), ...
        heating_rate_func(), ...
        ic_file_func(), ...
        ic_fu_func(), ...
        ic_habit_func(), ...
        ic_habit_yang2013_func(), ...
        ic_properties_func(), ...
        include_func(), ...
        interpret_as_level_func(), ...
        isotropic_source_toa_func(), ...
        latitude_func(), ...
        longitude_func(), ...
        mc_azimuth_old_func(), ...
        mc_backward_func(), ...
        mc_backward_increment_func(), ...
        mc_backward_output_func(), ...
        mc_backward_writeback_func(), ...
        mc_basename_func(), ...
        mc_boxairmass_func(), ...
        mc_escape_func(), ...
        mc_forward_output_func(), ...
        mc_maxscatters_func(), ...
        mc_minphotons_func(), ...
        mc_minscatters_func(), ...
        mc_nca_func(), ...
        mc_photons_func(), ...
        mc_photons_file_func(), ...
        mc_polarisation_func(), ...
        mc_rad_alpha_func(), ...
        mc_randomseed_func(), ...
        mc_sensordirection_func(), ...
        mc_spectral_is_func(), ...
        mc_spherical_func(), ...
        mc_surface_reflectalways_func(), ...
        mc_vroom_func(), ...
        mixing_ratio_func() ...
        mol_abs_param_func(), ...
        mol_file_func(), ...
        mol_modify_func(), ...
        mol_tau_file_func(), ...
        n02_column_du_func(), ...
        n02_column_moleccm_2_func(), ...
        no_absorption_func(), ...
        no_scattering_func(), ...
        number_of_streams_func(), ...
        output_format_func(), ...
        output_process_func(), ...
        output_quantity_func(), ...
        output_user_func(), ...
        ozone_column_func(), ...
        phi_func(), ...
        phi0_func(), ...
        polradtran_func(), ...
        polradtran_max_delta_tau_func(), ...
        polradtran_quad_type_func(), ...
        pressure_func(), ...
        pressure_out_func(), ... % this needs extra work...
        print_disort_info_func(), ...
        profile_file_func(), ...
        profile_modify_func(), ... % also needs work...
        psuedospherical_func(), ...
        quiet_func(), ...
        radiosonde_func(), ...
        radiosonde_levels_only_func(), ...
        raman_func(), ...
        rayleigh_depol_func(), ...
        refractive_index_pv_func(), ...
        reptran_file_func(), ...
        reverse_atmosphere_func(), ...
        rte_solver_func(), ...
        sdisort_func(), ...
        slit_function_file_func(), ...
        source_func(), ...
        spline_func(), ...
        spline_file_func(), ...
        sslidar_func(), ...
        sslidar_nranges_func(), ...
        sslidar_polarisation_func(), ...
        sur_temperature_func(), ...
        surface_type_map_func(), ...
        sza_func(), ...
        sza_file_func(), ...
        thermal_binds_file_func(), ...
        thermal_bandwidth_func(), ...
        time_func(), ...
        twomaxrnd3C_scale_cf_func(), ...
        tzs_cloud_top_height_func(), ...
        umu_func(), ...
        verbose_func(), ...
        wavelength_func(), ...
        wavelength_grid_file_func(), ...
        wavelength_index_func(), ...
        wc_file_func(), ...
        wc_modify_func(), ...
        wc_properties_func(), ...
        z_interpolate_func(), ...
        zout_func(), ...
        zout_interpolate_func(), ...
        zout_sea_func(), ...
        };
end


